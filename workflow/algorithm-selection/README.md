# অ্যালগরিদম সিলেকশন

> Prediction is very difficult, especially if it's about the future - Niels Bohr

***

দেখতে দেখতে আমরা মেশিন লার্নিংয়ের তৃতীয় ধাপে এসে পড়লাম। এত এত লার্নিং অ্যালগরিদমের মধ্যে কোনটা আমার জন্য বেস্ট চয়েস হবে সেটা কীভাবে নির্ধারণ করব।

কাজের ধারা যদি আরেকবার দেখি তাহলে এমন দাঁড়াবে,

![algo_workflow](http://i.imgur.com/LJ8yM4f.png)

## এই চ্যাপ্টারের ওভারভিউ


আমরা এই চ্যাপ্টারে পর্বে আলোচনা করব,

* লার্নিং অ্যালগরিদমের কাজ কী
* অ্যালগরিদম সিলেক্ট করব কোন কোন ক্রাইটেরিয়ার ভিত্তিতে
	* অ্যালগরিদম বাছাইয়ের জন্য সল্যুশন স্টেটমেন্ট ব্যবহার করব
	* বেস্ট অ্যালগরিদম কোনটা হবে সেটা নিয়ে আলোচনা করব
	* প্রাথমিক অ্যালগরিদম বাছাই করব
		* প্রাথমিক বলার কারণ হচ্ছে, একই প্রবলেম অনেক সময় একটা অ্যালগরিদম দিয়ে রান করা ঠিক না, সবসময় আমাদের বেস্ট অ্যালগরিদমের পেছনে ছুটতে হবে। তাই যতটা পারা যায় একই ডেটাসেট বিভিন্ন অ্যালগরিদম দিয়ে ট্রেইন করে পার্ফর্মেন্স টেস্ট করা জরুরি। তবে কাজ করার জন্য প্রথমে একটা অ্যালগরিদম নিয়ে বাছাই করতে হবে, সেটাই এখানে আলোচনা করা হবে।


## লার্নিং অ্যালগরিদমের কাজ

ব্যাপারটা হাস্যকর শোনালেও প্রথমে আমাদের বুঝতে হবে মেশিন লার্নিং প্রসেসে অ্যালগরিদমের কাজ কী। তাহলে একটু দেখা যাক,


লার্নিং অ্যালগরিদমকে ইঞ্জিনের সাথে তুলনা করা যায় যেটা পুরো মেশিন লার্নিং প্রসেস পরিচালনা করে। ডেটা প্রিপ্রসেসিং পরের গুরুত্বপূর্ণ কাজই হল লার্নিং অ্যালগরিদমের কাজ।

আমরা প্রথমে আমাদের ডেটাসেটকে দুইভাবে ভাগ করি,

* ট্রেইনিং ডেটা (বেশি পরিমাণে থাকে; টেস্টিং ডেটা এখান থেকে বাদ দেওয়া হয়)
* টেস্টিং ডেটা  (অল্প পরিমাণে থাকে; ট্রেইনিং ডেটাসেট এর কোন ডেটা টেস্টিং ডেটাসেট এ থাকে না)	

এবার এই ট্রেইনিং ডেটা আমরা অ্যালগরিদমে Feed করি, সাধারণত `Scikit-learn` এ অ্যালগরিদমে ফিড ও অ্যানালাইসিসের কাজ করার জন্য `fit()` ফাংশন ব্যবহার করলেই হয়। 

![fit](http://i.imgur.com/GgtvjS6.png)


এই অ্যালগরিদমের পিছনে কাজ করে ম্যাথমেটিক্যাল মডেল। এই ম্যাথমেটিক্যাল মডেলের মাধ্যমে অ্যালগরিদম ডেটাসেট অ্যানালাইসিসের সময় ইন্টারনাল প্যারামিটারগুলো ঠিকঠাক করে নেয়। এই কাজগুলো বোঝার জন্য ম্যাথ নিয়ে আলোচনা করা দরকার, কিন্তু আমরা আপাতত কাজ চালিয়ে নেওয়ার জন্য সবকিছু `magic` হিসেবে বিবেচনা করে কাজ আগাতে পারি। অবশ্যই আমরা ম্যাথমেটিক্যাল অ্যানালাইসিস দেখব, কিন্তু এখন পার্ফেক্ট সময় নয়। ম্যাথ নিয়ে গুতাগুতি করলে হয়ত ইন্টারেস্ট হারাতে পারেন, তাই আমরা আগে গাড়ি চালানো শিখব পরে দেখব ইঞ্জিন অর্থাৎ, লার্নিং অ্যালগরিদম কীভাবে কাজ করে।

![math_model](http://i.imgur.com/bvEvpSY.png)

এর পরের কাজ সহজ, `predict()` ফাংশন কল করার মাধ্যমে আমরা ডেটাসেট এ নাই এমন জিনিস প্রেডিক্ট করতে পারি (যেমন, ডায়বেটিস নির্ণয়ের জন্য আগে `Pima Indian Dataset` দিয়ে মডেল ট্রেইন করব `fit()` ফাংশন দিয়ে, তারপর যেকোন ব্যক্তির ওই প্যারামিটারের ডেটাগুলো দিয়ে `predict()` ফাংশনের মাধ্যমে জানব তার ডায়বেটিস হওয়ার সম্ভাবনা করতটুকু)

![predict](http://i.imgur.com/FWDAbaL.png)

***

## কোন অ্যালগরিদম দিয়ে ট্রেইন ও প্রেডিক্ট করব?

প্রায় ৫০ টার উপরে প্রতিষ্ঠিত লার্নিং অ্যালগরিদম আছে। আবার এগুলোর মাঝে ক্রসওভার করিয়ে আপনি নিজেও কাস্টম অ্যালগরিদম তৈরি করতে পারেন। কিন্তু কীভাবে বুঝব আমাদের কাজের জন্য কোন অ্যালগরিদমটা পার্ফেক্ট? সেটা নিয়ে আলোচনা করার জন্যই এই টপিক।

অ্যালগরিদম বাছাই করার জন্য প্রত্যেকেের নিজস্ব কিছু সিলেক্ট করা ফ্যাক্টর থাকে। যখন আপনি এক্সপার্ট হবেন তখন আপনি নিজেই বুঝতে পারবেন কোন অ্যালগরিদম কোন কাজের জন্য বেস্ট। 

আপাতত এই ফ্যাক্টরগুলোর উপর ভিত্তি করে বাছাই করতে পারেন।

### Algorithm Decision Factors

* লার্নিং টাইপ (Supervised নাকি Unsupervised)
* রেজাল্ট (Value নাকি Yes/No টাইপ উত্তর)
* কম্প্লেক্সিটি (Simple নাকি Complex)
* বেসিক না অ্যাডভান্সড

আমরা সল্যুশন স্টেটমেন্ট ও ওয়ার্কফ্লো প্রসেস, দুইটার কম্বিনেশনে সিলেক্ট করব কোন অ্যালগরিদম বাছাই করা ভাল হবে।

* ####  লার্নিং টাইপ

একেক অ্যালগরিদমের লার্নিং প্রসেস আলাদা। চলুন সল্যুশন স্টেটমেন্ট আগে একবার দেখি তারপর ঠিক করি আমাদের কোন ধরণের লার্নিং দরকার।

> মেশিন লার্নিং ওয়ার্কফ্লো ব্যবহার করে Pima Indian Data কে প্রিপ্রসেস ও প্রয়োজনীয় ট্রান্সফর্মেশন করার পর একটা **প্রেডিক্টিভ মডেল** তৈরি করতে হবে।
এবার এই মডেলকে ৭০% বা তারও বেশি অ্যাকুরেসির সাথে নির্ণয় করতে হবে কে কে ডায়বেটিসে আক্রান্ত হতে পারে।



উপরের স্টেটমেন্টে বোল্ড করা অংশতে আমরা দেখতে পাই সেখানে **প্রেডিক্টিভ মডেল** বিল্ড করার কথা বলা হয়েছে। 

আমরা জানি,

`Prediction Model => Supervised Machine Learning`

অর্থাৎ, আমরা পেয়ে গেলাম আমাদের বাছাইকৃত অ্যালগরিদমের লার্নিং টাইপ কী হবে।

**ফাইনালি, যেসব অ্যালগরিদম Unsupervised Learning নিয়ে কাজ করে ওগুলো আমরা ব্যবহার করব না**

এতে করে,

##### ২২ টি অ্যালগরিদম বাদ পড়ে গেল, হাতে থাকল ২৮ টা অ্যালগরিদম

তাও অনেক! সমস্যা নাই, একে একে আমরা আরও ফিল্টার করতে পারব।

* ####  রেজাল্ট টাইপ

আগেই বলেছি, আমরা সাধারণত দুই ধরণের উত্তর পেতে চাই। একটা হল ভ্যালু (Regression: যেমন বাড়ির আকারের সাথে দরদাম কেমন হবে) আরেকটা হল হ্যাঁ/না টাইপ উত্তর (Classification)।

এখানে বোঝাই যাচ্ছে ডায়বেটিস সমস্যা নির্ধারণ আসলে Classification, কারণ আমরা জানতে চাচ্ছি ডায়বেটিস হবে কি না। আবার, ডিস্ক্রিট ভ্যালু; যেমন: `1-100, 101-200, 201-300` বা `small, medium, large` ইত্যাদিও ক্লাসিফিকেশনের মধ্যে পড়ে।


এবার দেখি কয়টা অ্যালগরিদম বাদ পড়ল,

##### রেজাল্ট টাইপ ক্লাসিফিকেশন হওয়াতে বাদ পড়ল ৮ টা অ্যালগরিদম, হাতে রইল ২০ টা



* ####  কমপ্লেক্সিটি

আমরা যেহেতু মেশিন লার্নিং শেখা শুরু করেছি সেহেতু আমাদের উচিৎ জটিল অ্যালগরিদমগুলো এড়িয়ে চলা। তারমানে KISS (Keep It Short and Simple) ফরমূলা অ্যাপ্লাই করা।

**জটিল অ্যালগরিদম কোনগুলো?**

* Ensemble Algorithms:
	* এগুলো স্পেশাল অ্যালগরিদম, কারণ একেকটা Ensemble Algorithm অনেকগুলা অ্যালগরিদমের সমষ্টি হয়ে থাকে।
	* খুবই ভাল পার্ফর্মেন্স
	* ডিবাগিং করা সুবিধাজনক নয়

##### এতে করে অ্যালগরিদম কমে দাঁড়াল ১৪ টাতে

* #### Basic নাকি Enhanced?

**Enhanced**

* Basic এর ভ্যারিয়েশন
* পার্ফর্মেন্স Basic এর চেয়ে বেটার (বলা লাগে নাকি? :P)
* অতিরিক্ত সুবিধাসমৃদ্ধ
* **Complex**

**Basic**

* সহজ
* তাই সহজে বোঝা যায় 


হ্যাঁ বুঝতে পারছেন, যেহেতু আমরা বিগিনার, তাই আমাদের Basic এ থাকাই ভাল।

***

### ফিল্টারিং শেষে তিনটা Candidate Algorithm


আমরা এখন তিনটা অ্যালগরিদম, 

* Naive Bayes
* Logistic Regression
* Decision Tree

এর মধ্য থেকে একটা বাছাই করব। তিনটা সম্পর্কে আগে অল্প কিছু আলোচনা করার পর আমরা একটা ডিসিশনে আসব যে কোনটা ব্যবহার করা বেটার। তিনটাই মেশিন লার্নিংয়ের বেসিক ও ক্লাসিক অ্যালগরিদম। জটিল অ্যালগরিদমগুলো মূলত এগুলোকে বিল্ডিং ব্লক হিসেবে ব্যবহার করে গঠিত। Naive Bayes দিয়ে শুরু করা যাক।

* ####  Naive Bayes

![naive](http://i.imgur.com/HBqtWmQ.png)

Naive Bayes অ্যালগরিদম 'Bayes Theorem'  অ্যাপ্লাই করে বানানো। যারা 'Bayes Theorem' এর নাম শোনেন নি তাদের জন্য বলা যেতে পারে, Probability এর অন্যতম ফান্ডামেন্টাল থিওরেম হল 'Bayes Probability Theorem'। খুবই গুরুত্বপূর্ণ থিওরেম হওয়াতে এটা নিয়ে বিস্তারিত পরে একসময় আলোচনা করা হবে। (আবারও ম্যাথমেটিক্স)

'Naive Bayes' অ্যালগরিদম কোন কিছু হওয়ার সম্ভাবনা নির্ধারণ করে। যেমন, High Blood Pressure এর সাথে ডায়বেটিস হওয়ার সম্ভাবনা কেমন? এভাবে বিভিন্ন 'Feature / Input Variable' এর সাথে Probability মিক্স করে কোন ঘটনা হওয়ার সম্ভাবনা নির্ধারণ করে এই অ্যালগরিদম (অবশ্যই পূর্বের ডেটাসেট এর উপর ভিত্তি করে)।

**এর কিছু বৈশিষ্ট্য হল**

* ঘটনা ঘটার সম্ভাবনা নির্ধারণ করে
* প্রতিটি ফিচার বা ইনপুট ভ্যারিয়েবল (আলোচ্য সমস্যার ক্ষেত্রে: no of preg, insulin, ইত্যাদি) সমান গুরুত্বপূর্ণ।
	* তারমানে এখানে Blood Pressure আর BMI (Body Mass Index) সমান গুরুত্বপূর্ণ (পাশাপাশি সব ভ্যারিয়েবল-ই)

* প্রেডিকশনের জন্য অল্প পরিমাণ ডেটাই যথেষ্ট


* ####  লজিস্টিক রিগ্রেশন (Logistic Regression)

![logistic](http://i.imgur.com/Pi3h18A.png)

নামটা কনফিউজিং, মানে আমরা জানতাম Regression মানে Continuous সম্পর্কিত। কিন্তু Classification হল Discrete ভ্যালু। মনে হতেই পারে, Classification করার জন্য আমরা Regression মেথড নিয়ে আলোচনা কেন করছি? 

আসলে Logistic Regression এর আউটপুট ১ (.৯৯৯৯) বা ০ (০.০০০০১) হয়।

**বৈশিষ্ট্য**

* বাইনারি রেজাল্ট
* Input Variable / Feature এর রিলেশনশিপ Weighted করা হয় (সবগুলা ফিচার সমান গুরুত্বপূর্ণ নাও হতে পারে)

পরবর্তী অ্যালগরিদম দেখা যাক।

***

* ####  ডিসিশন ট্রি (Decision Tree)

![decision](http://i.imgur.com/rTQD7Mu.png)

* এর গঠন বাইনারি ট্রি এর মত (ডেটা স্ট্রাকচার পড়ে থাকলে ধারণা করতে পারবেন)
* প্রতিটা নোড আসলে একেকটা ডিসিশন
* প্রচুর পরিমাণ ডেটা লাগে ডিসিশন স্প্লিটংয়ের জন্য

### অবশেষে সিলেক্ট করলাম `Naive Bayes`

#### কেন?

* সহজে বোঝা যায়
* দ্রুত কাজ করে (প্রায় ১০০ গুণ দ্রুত সাধারণ অ্যালগরিদমের তুলনায়)
* ডেটা চেঞ্জ হলেও মডেল স্টেবল থাকে
	* ডিবাগিং করা তুলনামূলক সহজ
* সবচেয়ে বড় কারণ হল, আমাদের সমস্যার সাথে এই অ্যালগরিদমটা পুরোপুরি ম্যাচ করে, কারণ আমরা likelihood বের করতে চাচ্ছি এবং এই অ্যালগরিদমের কাজই হল likelihood নির্ণয় করা :)




## সারাংশ

* প্রচুর লার্নিং অ্যালগরিদম অ্যাভেইলেবল
* সিলেকশন করলাম
 * Learning Type - Supervised
 * Result - Binary Classification
 * Complexity - Non-Ensemble
 * Basic or Enhanced - Basic

* Naive Bayes সিলেক্ট করলাম ট্রেনিংয়ের জন্য, কারণ
	* সহজ, ফাস্ট ও স্টেবল


পরবর্তী চ্যাপ্টারেই আমরা আশা করি প্রেডিক্ট করতে পারব (Promise!)


